using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace BbQ.MockLite.Generators;

[Generator]
public class InterfaceMockGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        var compilation = context.Compilation;
        var targets = DiscoverTargets(compilation);

        foreach (var iface in targets)
        {
            var source = GenerateMockSource(compilation, iface);
            var className = GetMockClassName(iface.Name);
            context.AddSource($"{className}.g.cs", source);
        }
    }

    private static IEnumerable<INamedTypeSymbol> DiscoverTargets(Compilation compilation)
    {
        var results = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        foreach (var tree in compilation.SyntaxTrees)
        {
            var model = compilation.GetSemanticModel(tree, ignoreAccessibility: true);
            var root = tree.GetRoot();

            foreach (var ifaceDecl in root.DescendantNodes().OfType<InterfaceDeclarationSyntax>())
            {
                var symbol = model.GetDeclaredSymbol(ifaceDecl) as INamedTypeSymbol;
                if (symbol is null) continue;

                if (symbol.GetAttributes().Any(a => a.AttributeClass?.Name == nameof(GenerateMockAttribute)))
                    results.Add(symbol);
            }

            foreach (var classDecl in root.DescendantNodes().OfType<ClassDeclarationSyntax>())
            {
                var classSymbol = model.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
                if (classSymbol is null) continue;

                foreach (var attr in classSymbol.GetAttributes())
                {
                    var name = attr.AttributeClass?.Name;
                    if (name is null) continue;

                    if (name == nameof(GenerateMockAttribute) && attr.ConstructorArguments.Length == 1)
                    {
                        if (attr.ConstructorArguments[0].Value is INamedTypeSymbol t && t.TypeKind == TypeKind.Interface)
                            results.Add(t);
                    }
                    else if (name.StartsWith(nameof(GenerateMockAttribute)) && attr.AttributeClass?.TypeArguments.Length == 1)
                    {
                        var t = attr.AttributeClass.TypeArguments[0] as INamedTypeSymbol;
                        if (t is { TypeKind: TypeKind.Interface })
                            results.Add(t);
                    }
                }
            }
        }

        return results;
    }

    private static string GetMockClassName(string ifaceName)
        => (ifaceName.Length > 1 && ifaceName[0] == 'I' && char.IsUpper(ifaceName[1]))
            ? $"Mock{ifaceName.Substring(1)}"
            : $"Mock{ifaceName}";

    private static string GenerateMockSource(Compilation compilation, INamedTypeSymbol iface)
    {
        var ns = iface.ContainingNamespace.IsGlobalNamespace ? null : iface.ContainingNamespace.ToDisplayString();
        var className = GetMockClassName(iface.Name);
        var ifaceDisplay = iface.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using BbQ.MockLite;");

        if (!string.IsNullOrEmpty(ns)) sb.AppendLine($"namespace {ns} {{");
        sb.AppendLine("[GeneratedMock]");
        sb.AppendLine($"public sealed class {className} : {ifaceDisplay}");
        sb.AppendLine("{");
        sb.AppendLine("    public List<Invocation> Invocations { get; } = new();");

        // Behavior fields per method overload with signature hash
        var methods = iface.GetMembers().OfType<IMethodSymbol>().Where(m => m.MethodKind == MethodKind.Ordinary).ToList();
        foreach (var m in methods)
        {
            var field = BehaviorFieldName(m);
            var delType = BehaviorDelegateType(m);
            sb.AppendLine($"    public {delType}? {field} {{ get; set; }}");
        }

        // Property behavior fields
        foreach (var p in iface.GetMembers().OfType<IPropertySymbol>())
        {
            if (p.GetMethod is not null)
                sb.AppendLine($"    public Func<{TypeDisplay(p.Type)}>? {GetBehaviorFieldName(p)} {{ get; set; }}");
            if (p.SetMethod is not null)
                sb.AppendLine($"    public Action<{TypeDisplay(p.Type)}>? {SetBehaviorFieldName(p)} {{ get; set; }}");
            sb.AppendLine($"    private {TypeDisplay(p.Type)}? _{p.Name};");
        }

        // Implement methods
        foreach (var m in methods)
        {
            sb.Append(EmitMethodImplementation(m));
            sb.Append(EmitMethodSetup(m));
            sb.Append(EmitMethodSetupWithMatcher(m));
            sb.Append(EmitMethodReturns(m));
            sb.Append(EmitMethodVerify(m));
            sb.Append(EmitMethodVerifyWithMatcher(m));
        }

        // Implement properties
        foreach (var p in iface.GetMembers().OfType<IPropertySymbol>())
        {
            sb.Append(EmitPropertyImplementation(p));
            if (p.GetMethod is not null)
            {
                sb.Append(EmitPropertyGetSetup(p));
                sb.Append(EmitPropertyGetVerify(p));
            }
            if (p.SetMethod is not null)
            {
                sb.Append(EmitPropertySetSetup(p));
                sb.Append(EmitPropertySetSetupWithMatcher(p));
                sb.Append(EmitPropertySetVerify(p));
                sb.Append(EmitPropertySetVerifyWithMatcher(p));
            }
        }

        sb.AppendLine("    private static string BuildMessage(string member, Func<int, bool> times, int actual, string? message)");
        sb.AppendLine("    {");
        sb.AppendLine("        var expected = times.Method.Name;");
        sb.AppendLine("        var line = $\"Verification failed for {member}. Expected: {expected}. Actual calls: {actual}.\";");
        sb.AppendLine("        return string.IsNullOrWhiteSpace(message) ? line : $\"{line} {message}\";");
        sb.AppendLine("    }");

        sb.AppendLine("}"); // class
        if (!string.IsNullOrEmpty(ns)) sb.AppendLine("}"); // namespace

        return sb.ToString();
    }

    private static string TypeDisplay(ITypeSymbol t)
        => t.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

    // Signature hash to disambiguate overloads and generics
    private static string SignatureHash(IMethodSymbol m)
    {
        var typeParams = m.IsGenericMethod
            ? "<" + string.Join(",", m.TypeParameters.Select(tp => tp.Name)) + ">"
            : "";
        var args = string.Join(",", m.Parameters.Select(p => TypeDisplay(p.Type)));
        return $"{m.Name}{typeParams}({args})";
    }

    private static string BehaviorFieldName(IMethodSymbol m)
    {
        var hash = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(SignatureHash(m)))
            .TrimEnd('=')
            .Replace('+', '_')
            .Replace('/', '-');
        return $"{m.Name}_{hash}_Behavior";
    }

    private static string BehaviorDelegateType(IMethodSymbol m)
    {
        var returns = TypeDisplay(m.ReturnType);
        var parms = m.Parameters.Select(p => TypeDisplay(p.Type)).ToList();

        if (returns == "void")
            return parms.Count == 0 ? "Action" : $"Action<{string.Join(", ", parms)}>";

        if (returns == "Task")
            return parms.Count == 0 ? "Func<Task>" : $"Func<{string.Join(", ", parms)}, Task>";

        if (returns.StartsWith("Task<"))
        {
            var genericRet = returns.Substring(5, returns.Length - 6);
            parms.Add(returns); // Use the full Task<T> type
            return $"Func<{string.Join(", ", parms)}>";
        }

        if (returns == "ValueTask")
            return parms.Count == 0 ? "Func<ValueTask>" : $"Func<{string.Join(", ", parms)}, ValueTask>";

        if (returns.StartsWith("ValueTask<"))
        {
            var genericRet = returns.Substring(10, returns.Length - 11);
            parms.Add(returns); // Use the full ValueTask<T> type
            return $"Func<{string.Join(", ", parms)}>";
        }

        parms.Add(returns);
        return $"Func<{string.Join(", ", parms)}>";
    }

    private static string EmitMethodImplementation(IMethodSymbol m)
    {
        var name = m.Name;
        var parmsSig = string.Join(", ", m.Parameters.Select(p => $"{TypeDisplay(p.Type)} {p.Name}"));
        var ret = TypeDisplay(m.ReturnType);
        var iface = TypeDisplay(m.ContainingType);
        var argsArray = string.Join(", ", m.Parameters.Select(p => p.Name));
        var field = BehaviorFieldName(m);
        var sb = new StringBuilder();

        sb.AppendLine($"    public {ret} {name}({parmsSig})");
        sb.AppendLine("    {");
        sb.AppendLine($"        var mi = typeof({iface}).GetMethod(\"{name}\")!;");
        sb.AppendLine($"        Invocations.Add(new Invocation(mi, new object[] {{ {argsArray} }}));");

        if (ret == "void")
        {
            sb.AppendLine($"        {field}?.Invoke({argsArray});");
        }
        else if (ret == "Task")
        {
            sb.AppendLine($"        return {field}?.Invoke({argsArray}) ?? Task.CompletedTask;");
        }
        else if (ret.StartsWith("Task<"))
        {
            var tArg = ret.Substring(5, ret.Length - 6);
            sb.AppendLine($"        if ({field} != null) return {field}({argsArray});");
            sb.AppendLine($"        return Task.FromResult(default({tArg}))!;");
        }
        else if (ret == "ValueTask")
        {
            sb.AppendLine($"        return {field}?.Invoke({argsArray}) ?? default;");
        }
        else if (ret.StartsWith("ValueTask<"))
        {
            var tArg = ret.Substring(10, ret.Length - 11);
            sb.AppendLine($"        if ({field} != null) return {field}({argsArray});");
            sb.AppendLine($"        return new ValueTask<{tArg}>(default);");
        }
        else
        {
            sb.AppendLine($"        return {field}?.Invoke({argsArray}) ?? default({ret})!;");
        }

        sb.AppendLine("    }");
        return sb.ToString();
    }

    private static string EmitMethodSetup(IMethodSymbol m)
    {
        var className = GetMockClassName(m.ContainingType.Name);
        var field = BehaviorFieldName(m);
        var behaviorType = BehaviorDelegateType(m);
        return $"    public {className} Setup{m.Name}({behaviorType} behavior) {{ {field} = behavior; return this; }}\n";
    }

    private static string EmitMethodSetupWithMatcher(IMethodSymbol m)
    {
        var className = GetMockClassName(m.ContainingType.Name);
        var field = BehaviorFieldName(m);
        var ret = TypeDisplay(m.ReturnType);
        var args = string.Join(", ", m.Parameters.Select(p => p.Name));
        var matcherSig = string.Join(", ", m.Parameters.Select(p => $"Func<{TypeDisplay(p.Type)}, bool> {p.Name}Matcher"));
        var conj = m.Parameters.Length == 0 ? "true" : string.Join(" && ", m.Parameters.Select(p => $"{p.Name}Matcher({p.Name})"));

        var sb = new StringBuilder();
        sb.AppendLine($"    public {className} Setup{m.Name}({matcherSig}{(matcherSig.Length > 0 ? ", " : "")} {BehaviorDelegateType(m)} behavior)");
        sb.AppendLine("    {");
        if (ret == "void")
        {
            sb.AppendLine($"        {field} = ({args}) => {{ if ({conj}) behavior({args}); }};");
        }
        else if (ret == "Task" || ret.StartsWith("Task<") || ret == "ValueTask" || ret.StartsWith("ValueTask<"))
        {
            // For async methods, the behavior already returns the correct async type
            sb.AppendLine($"        {field} = ({args}) => ({conj}) ? behavior({args}) : GetDefault{m.Name}();");
            sb.AppendLine("        return this;");
            sb.AppendLine("    }");
            sb.AppendLine();
            // Add helper to generate default async result
            var def = ret switch
            {
                "Task" => "Task.CompletedTask",
                var s when s.StartsWith("Task<") => $"Task.FromResult(default({s.Substring(5, s.Length - 6)})!)",
                "ValueTask" => "default",
                var s when s.StartsWith("ValueTask<") => $"new ValueTask<{s.Substring(10, s.Length - 11)}>(default)",
                _ => $"default({ret})",
            };
            sb.AppendLine($"    private static {ret} GetDefault{m.Name}() => {def};");
            return sb.ToString();
        }
        else
        {
            var def = $"default({ret})";
            sb.AppendLine($"        {field} = ({args}) => ({conj}) ? behavior({args}) : {def};");
        }
        sb.AppendLine($"        return this;");
        sb.AppendLine("    }");
        return sb.ToString();
    }

    private static string EmitMethodReturns(IMethodSymbol m)
    {
        var className = GetMockClassName(m.ContainingType.Name);
        var field = BehaviorFieldName(m);
        var ret = TypeDisplay(m.ReturnType);
        var args = string.Join(", ", m.Parameters.Select(p => p.Name));
        var sb = new StringBuilder();

        if (ret.StartsWith("Task<"))
        {
            var tArg = ret.Substring(5, ret.Length - 6);
            sb.AppendLine($"    public {className} Returns{m.Name}({tArg} result) {{ {field} = ({args}) => Task.FromResult(result); return this; }}");
        }
        else if (ret == "Task")
        {
            sb.AppendLine($"    public {className} Returns{m.Name}() {{ {field} = ({args}) => Task.CompletedTask; return this; }}");
        }
        else if (ret.StartsWith("ValueTask<"))
        {
            var tArg = ret.Substring(10, ret.Length - 11);
            sb.AppendLine($"    public {className} Returns{m.Name}({tArg} result) {{ {field} = ({args}) => new ValueTask<{tArg}>(result); return this; }}");
        }
        else if (ret == "ValueTask")
        {
            sb.AppendLine($"    public {className} Returns{m.Name}() {{ {field} = ({args}) => default; return this; }}");
        }
        else if (ret != "void")
        {
            sb.AppendLine($"    public {className} Returns{m.Name}({ret} result) {{ {field} = ({args}) => result; return this; }}");
        }
        return sb.ToString();
    }

    private static string EmitMethodVerify(IMethodSymbol m)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"    public void Verify{m.Name}(Func<int, bool> times, string? message = null)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var count = Invocations.Count(i => i.Method.Name == nameof({m.Name}));");
        sb.AppendLine($"        if (!times(count)) throw new VerificationException(BuildMessage(nameof({m.Name}), times, count, message));");
        sb.AppendLine("    }");
        return sb.ToString();
    }

    private static string EmitMethodVerifyWithMatcher(IMethodSymbol m)
    {
        var matcherSig = string.Join(", ", m.Parameters.Select(p => $"Func<{TypeDisplay(p.Type)}, bool> {p.Name}Matcher"));
        var sb = new StringBuilder();
        sb.AppendLine($"    public void Verify{m.Name}({matcherSig}{(matcherSig.Length > 0 ? ", " : "")}Func<int, bool> times, string? message = null)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var count = Invocations.Count(i => i.Method.Name == nameof({m.Name}) && {BuildArgMatcherPredicate(m)});");
        sb.AppendLine($"        if (!times(count)) throw new VerificationException(BuildMessage(nameof({m.Name}), times, count, message));");
        sb.AppendLine("    }");
        return sb.ToString();
    }

    private static string BuildArgMatcherPredicate(IMethodSymbol m)
        => m.Parameters.Length == 0 ? "true"
           : string.Join(" && ", m.Parameters.Select((p, idx) => $"{p.Name}Matcher(({TypeDisplay(p.Type)})i.Arguments[{idx}])"));

    private static string EmitPropertyImplementation(IPropertySymbol p)
    {
        var name = p.Name;
        var type = TypeDisplay(p.Type);
        var iface = TypeDisplay(p.ContainingType);
        var sb = new StringBuilder();

        sb.AppendLine($"    public {type} {name}");
        sb.AppendLine("    {");
        if (p.GetMethod is not null)
        {
            sb.AppendLine("        get");
            sb.AppendLine("        {");
            sb.AppendLine($"            var mi = typeof({iface}).GetProperty(\"{name}\")!.GetGetMethod()!;");
            sb.AppendLine("            Invocations.Add(new Invocation(mi, Array.Empty<object>()));");
            sb.AppendLine($"            if ({GetBehaviorFieldName(p)} is not null) return {GetBehaviorFieldName(p)}();");
            sb.AppendLine($"            return _{name}!;");
            sb.AppendLine("        }");
        }
        if (p.SetMethod is not null)
        {
            sb.AppendLine("        set");
            sb.AppendLine("        {");
            sb.AppendLine($"            var mi = typeof({iface}).GetProperty(\"{name}\")!.GetSetMethod()!;");
            sb.AppendLine($"            Invocations.Add(new Invocation(mi, new object[] {{ value }}));");
            sb.AppendLine($"            if ({SetBehaviorFieldName(p)} is not null) {{ {SetBehaviorFieldName(p)}(value); }} else _{name} = value;");
            sb.AppendLine("        }");
        }
        sb.AppendLine("    }");

        return sb.ToString();
    }

    private static string EmitPropertyGetSetup(IPropertySymbol p)
    {
        var className = GetMockClassName(p.ContainingType.Name);
        var type = TypeDisplay(p.Type);
        var sb = new StringBuilder();
        sb.AppendLine($"    public {className} SetupGet{p.Name}(Func<{type}> behavior) {{ {GetBehaviorFieldName(p)} = behavior; return this; }}");
        sb.AppendLine($"    public {className} ReturnsGet{p.Name}({type} value) {{ {GetBehaviorFieldName(p)} = () => value; return this; }}");
        return sb.ToString();
    }

    private static string EmitPropertyGetVerify(IPropertySymbol p)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"    public void VerifyGet{p.Name}(Func<int, bool> times, string? message = null)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var count = Invocations.Count(i => i.Method.Name == \"get_{p.Name}\");");
        sb.AppendLine($"        if (!times(count)) throw new VerificationException(BuildMessage(\"get_{p.Name}\", times, count, message));");
        sb.AppendLine("    }");
        return sb.ToString();
    }

    private static string EmitPropertySetSetup(IPropertySymbol p)
    {
        var className = GetMockClassName(p.ContainingType.Name);
        var type = TypeDisplay(p.Type);
        var sb = new StringBuilder();
        sb.AppendLine($"    public {className} SetupSet{p.Name}(Action<{type}> behavior) {{ {SetBehaviorFieldName(p)} = behavior; return this; }}");
        return sb.ToString();
    }

    private static string EmitPropertySetSetupWithMatcher(IPropertySymbol p)
    {
        var className = GetMockClassName(p.ContainingType.Name);
        var type = TypeDisplay(p.Type);
        var sb = new StringBuilder();
        sb.AppendLine($"    public {className} SetupSet{p.Name}(Func<{type}, bool> matcher, Action<{type}> behavior)");
        sb.AppendLine("    {");
        sb.AppendLine($"        {SetBehaviorFieldName(p)} = v => {{ if (matcher(v)) behavior(v); }};");
        sb.AppendLine("        return this;");
        sb.AppendLine("    }");
        return sb.ToString();
    }

    private static string EmitPropertySetVerify(IPropertySymbol p)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"    public void VerifySet{p.Name}(Func<int, bool> times, string? message = null)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var count = Invocations.Count(i => i.Method.Name == \"set_{p.Name}\");");
        sb.AppendLine($"        if (!times(count)) throw new VerificationException(BuildMessage(\"set_{p.Name}\", times, count, message));");
        sb.AppendLine("    }");
        return sb.ToString();
    }

    private static string EmitPropertySetVerifyWithMatcher(IPropertySymbol p)
    {
        var type = TypeDisplay(p.Type);
        var sb = new StringBuilder();
        sb.AppendLine($"    public void VerifySet{p.Name}(Func<{type}, bool> matcher, Func<int, bool> times, string? message = null)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var count = Invocations.Count(i => i.Method.Name == \"set_{p.Name}\" && matcher(({type})i.Arguments[0]));");
        sb.AppendLine($"        if (!times(count)) throw new VerificationException(BuildMessage(\"set_{p.Name}\", times, count, message));");
        sb.AppendLine("    }");
        return sb.ToString();
    }

    private static string GetBehaviorFieldName(IPropertySymbol p) => $"{p.Name}GetBehavior";
    private static string SetBehaviorFieldName(IPropertySymbol p) => $"{p.Name}SetBehavior";
}